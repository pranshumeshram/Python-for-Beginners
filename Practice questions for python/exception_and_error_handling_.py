# -*- coding: utf-8 -*-
"""Exception and Error Handling .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RdZXU4s6xxQ8cN5tI9mWhKb1wZ6Hq-Kc
"""



"""# Exception and Error Handling in Python

## 1. Types of Errors in Python

## a. Syntax Errors
A syntax error occurs when the Python interpreter finds incorrect syntax in the code. These errors prevent the program from running and are detected at compile-time.
"""

# Example of Syntax Error
if True
    print("Hello")

"""## b. Exceptions (Runtime Errors)

An exception occurs during the execution of the program (runtime). Even though the syntax is correct, the code may fail due to unforeseen circumstances such as dividing by zero or trying to access an element that doesnâ€™t exist in a list.
"""

# Example of Runtime Error (ZeroDivisionError)
result = 10 / 0

"""## 2. Exception Handling in Python

Python uses try-except blocks to handle exceptions gracefully. This prevents the program from crashing and allows us to provide a custom response when an error occurs.

## a. try-except Block
The try block contains the code that might throw an exception. If an error occurs, the except block is executed to handle the error.
"""

try:
    result = 10 / 0
except ZeroDivisionError:
    print("Error: You can't divide by zero!")

"""## b. Handling Multiple Exceptions
You can handle multiple types of exceptions by specifying multiple except blocks for different errors.
"""

try:
    num = int(input("Enter a number: "))
    result = 100 / num
except ValueError:
    print("Error: Invalid input, please enter a number.")
except ZeroDivisionError:
    print("Error: You can't divide by zero!")

"""## c. else Block
The else block is executed if no exceptions occur in the try block. It is useful for running code that should execute only if no errors are encountered.
"""

try:
    result = 10 / 2
except ZeroDivisionError:
    print("Error: You can't divide by zero!")
else:
    print("Result:", result)

"""## d. finally Block

The finally block contains code that is always executed, whether an exception occurs or not. It is often used to release resources or perform cleanup actions.
"""

from google.colab import files

uploaded = files.upload()

try:
    file = open("python_course.txt", "r")
    data = file.read()
except FileNotFoundError:
    print("Error: The file was not found.")
finally:
    file.close()
    print("File closed.")

"""## 3. Raising Exceptions
In some cases, you may want to manually raise an exception using the raise keyword. This is helpful when you want to enforce certain conditions in your code.
"""

def check_age(age):
    if age < 18:
        raise ValueError("Age must be 18 or older.")
    else:
        print("Access granted.")

try:
    check_age(15)
except ValueError as e:
    print(e)

"""## 4. Custom Exceptions
You can create your own custom exceptions by subclassing the built-in Exception class. This is useful when you want to define your own error types for specific situations.
"""

class CustomError(Exception):
    pass

def check_value(val):
    if val < 0:
        raise CustomError("Value cannot be negative!")
    return val

try:
    check_value(-5)
except CustomError as e:
    print(e)

"""## Example of Exception Handling"""

# Example 1: Division Program with Error Handling
try:
    num1 = int(input("Enter a number: "))
    num2 = int(input("Enter another number: "))
    result = num1 / num2
except ValueError:
    print("Error: Please enter valid integers.")
except ZeroDivisionError:
    print("Error: Division by zero is not allowed.")
else:
    print("Result:", result)
finally:
    print("Execution completed.")

2# Example 2: File Reading with Error Handling
try:
    with open("example.txt", "r") as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("Error: The file does not exist.")
except PermissionError:
    print("Error: You do not have permission to read the file.")
finally:
    print("File operation attempted.")

"""## Key Points
* Syntax Errors occur when there is a problem with the structure of your code, and Python cannot interpret it.
* Exceptions are runtime errors that occur during program execution.
* Exception handling with try-except blocks ensures that your program can handle errors gracefully without crashing.
* The else block runs if no exception occurs, while the finally block is executed regardless of whether an exception occurs or not.
* Custom exceptions allow you to create your own error types for specialized situations.
"""

